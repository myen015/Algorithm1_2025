# -*- coding: utf-8 -*-
"""ex9.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UAeAbMcecT9_I28je4yztmAR0e0fvif1
"""

from itertools import product

# --------------------------- Problem 1 -----------------------------------
# Finite functions F : {0,1}^n -> output set

def count_functions(output_set_size, n):
    """
    Count the number of possible functions {0,1}^n -> output_set
    Each of the 2^n inputs can map independently to any of output_set_size values
    """
    return output_set_size ** (2 ** n)

# Examples
n = 3  # input bits
print("\n=== Problem 1: Counting finite functions ===")
print(f"For n={n} input bits:")
print("Output {0,1} (binary): 2^(2^n) =", count_functions(2, n))
print("Output {-1,0,1}: 3^(2^n) =", count_functions(3, n))
m = 2  # number of output bits for {0,1}^m
print(f"Output {{0,1}}^{m}: 2^(m*2^n) =", count_functions(2**m, n))

# Explanation:
# Each input of 2^n possibilities can map independently to output set values.
# So total number of functions is |output_set|^(2^n)
# For m-bit output: each input has 2^m choices => total (2^m)^(2^n) = 2^(m*2^n)

# --------------------------- Problem 2 -----------------------------------
# NAND truth table:
# A B | A↑B
# 0 0 | 1
# 0 1 | 1
# 1 0 | 1
# 1 1 | 0

def nand(a, b):
    return int(not(a and b))

print("\n=== Problem 2: NAND ⇒ AND, OR, NOT ===")
# Generate NOT using NAND
def NOT(x):
    return nand(x, x)

# Generate AND using NAND
def AND(a, b):
    return NOT(nand(a, b))  # NAND + NOT

# Generate OR using NAND (De Morgan: a OR b = NOT(NOT a AND NOT b))
def OR(a, b):
    return nand(NOT(a), NOT(b))

# Demonstrate truth tables
inputs = list(product([0,1], repeat=2))
print("\nTruth tables:")
print("A B | NOT A | NOT B | A AND B | A OR B")
for a, b in inputs:
    print(f"{a} {b} | {NOT(a)}     | {NOT(b)}     | {AND(a,b)}       | {OR(a,b)}")

# --------------------------- Problem 3 -----------------------------------
# Universality of Boolean circuits
print("\n=== Problem 3: Universality of Boolean circuits ===")

def delta_x(n, x):
    """
    Return a function δ_x : {0,1}^n -> {0,1}
    δ_x(y) = 1 if y == x else 0
    Implemented as bitwise AND of equality checks
    """
    def f(y):
        return int(all(y[i] == x[i] for i in range(n)))
    return f

# Example: n=3, x=(1,0,1)
n = 3
x = (1,0,1)
delta = delta_x(n, x)
print(f"δ_{x} evaluated on all inputs:")
for y in product([0,1], repeat=n):
    print(f"y={y} => δ_x(y)={delta(y)}")

# Explanation:
# Each δ_x can be realized by O(n) gates (one comparison per bit using AND/NOT)
# Any Boolean function F can be written as sum of δ_x for which F(x)=1:
# F(y) = OR over all x s.t. F(x)=1 of δ_x(y)
# There are 2^n δ_x functions, each of size O(n)
# Therefore total size = O(n*2^n)

print("\nExplanation:")
print("- Each δ_x can be built using O(n) gates.")
print("- F can be represented as OR of δ_x for inputs where F=1.")
print("- Total circuit size O(n * 2^n).")