# -*- coding: utf-8 -*-
"""ex6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bdtgmdkzO-mQesGf0ZK3_4eUD_otU9cr
"""

from collections import deque
from dataclasses import dataclass, field
from typing import List

@dataclass
class NaryNode:
    weight: float
    children: List["NaryNode"] = field(default_factory=list)

    def __repr__(self):
        return f"NaryNode(weight={self.weight:.6f}, children={len(self.children)})"

def build_full_nary_tree(n: int, depth: int, root_weight: float) -> NaryNode:
    root = NaryNode(root_weight)
    if depth <= 0:
        return root
    def build(node: NaryNode, current_depth: int):
        if current_depth >= depth:
            return
        for _ in range(n):
            child = NaryNode(node.weight / n)
            node.children.append(child)
        for child in node.children:
            build(child, current_depth + 1)
    build(root, 0)
    return root

def dfs_sum(node: NaryNode) -> float:
    s = node.weight
    for c in node.children:
        s += dfs_sum(c)
    return s

def dfs_flip(node: NaryNode):
    node.weight = -node.weight
    for c in node.children:
        dfs_flip(c)

def bfs_sum_iterative(root: NaryNode) -> float:
    q = deque([root])
    s = 0.0
    while q:
        node = q.popleft()
        s += node.weight
        for c in node.children:
            q.append(c)
    return s

def bfs_sum_recursive(root: NaryNode) -> float:
    s = 0.0
    def helper(level_nodes):
        nonlocal s
        if not level_nodes:
            return
        next_level = []
        for node in level_nodes:
            s += node.weight
            next_level.extend(node.children)
        helper(next_level)
    helper([root])
    return s

def bfs_flip_recursive(root: NaryNode):
    def helper(level_nodes):
        if not level_nodes:
            return
        next_level = []
        for node in level_nodes:
            node.weight = -node.weight
            next_level.extend(node.children)
        helper(next_level)
    helper([root])

def bfs_flip_iterative(root: NaryNode):
    q = deque([root])
    while q:
        node = q.popleft()
        node.weight = -node.weight
        for c in node.children:
            q.append(c)

def run_tests(n: int, depth: int):
    print(f"\n=== Testing n={n}, depth={depth} ===")
    root_weight = 1.0 / (depth + 1)
    root = build_full_nary_tree(n, depth, root_weight)
    print(f"Root weight chosen: {root_weight}")
    s_dfs = dfs_sum(root)
    s_bfs_iter = bfs_sum_iterative(root)
    s_bfs_rec = bfs_sum_recursive(root)
    print(f"DFS recursive sum: {s_dfs:.12f}")
    print(f"BFS iterative sum: {s_bfs_iter:.12f}")
    print(f"BFS recursive sum: {s_bfs_rec:.12f}")
    eps = 1e-12
    for name, val in [("DFS", s_dfs), ("BFS_iter", s_bfs_iter), ("BFS_rec", s_bfs_rec)]:
        print(f"  {name} == 1? {'YES' if abs(val - 1.0) < eps else 'NO, diff=' + str(val-1.0)}")
    dfs_flip(root)
    print(f"After DFS flip 1: sum = {dfs_sum(root):.12f} (expect -1)")
    dfs_flip(root)
    print(f"After DFS flip 2: sum = {dfs_sum(root):.12f} (expect +1)")
    bfs_flip_iterative(root)
    print(f"After BFS iterative flip 1: sum = {bfs_sum_iterative(root):.12f} (expect -1)")
    bfs_flip_iterative(root)
    print(f"After BFS iterative flip 2: sum = {bfs_sum_iterative(root):.12f} (expect +1)")
    bfs_flip_recursive(root)
    print(f"After BFS recursive flip 1: sum = {bfs_sum_recursive(root):.12f} (expect -1)")
    bfs_flip_recursive(root)
    print(f"After BFS recursive flip 2: sum = {bfs_sum_recursive(root):.12f} (expect +1)")

for n in [2, 3, 5]:
    run_tests(n, depth=3)