# -*- coding: utf-8 -*-
"""ex5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19gGFA0mfCiOENKB6MDPjgH-enkgQgaYe

# Fundamental Algorithm Techniques - Problem Set #5

## Problem 1: Equivalence of Tree Definitions

Definitions:
1. A tree is a connected acyclic graph.
2. A tree is one component of a forest (a forest is an acyclic graph).
3. A tree is a connected graph with at most V-1 edges.
4. A tree is a minimally connected graph; removing any edge disconnects the graph.
5. A tree is an acyclic graph with at least V-1 edges.
6. A tree is a maximally acyclic graph; adding an edge between any two vertices creates a cycle.
7. A tree has a unique path between each pair of vertices.

Proof Sketch (Equivalence):
- (1 ⇒ 2): A tree is connected and acyclic, so it is one component of a forest.
- (1 ⇒ 3): Connected acyclic graph has exactly V-1 edges.
- (3 ⇒ 4): Removing any edge disconnects the graph ⇒ minimally connected.
- (4 ⇒ 1): Minimally connected ⇒ connected and acyclic (no cycles).
- (1 ⇒ 5): Connected acyclic ⇒ has at least V-1 edges.
- (5 ⇒ 6): Acyclic with V-1 edges ⇒ adding edge creates cycle ⇒ maximally acyclic.
- (6 ⇒ 1): Maximally acyclic ⇒ acyclic and connected.
- (1 ⇔ 7): Connected acyclic ⇔ exactly one path between any two vertices.

✅ Therefore, all definitions are equivalent.

## Problem 2: Sparse Graph Representation

- Vertices: {A, B, C, D, E} → indices 0–4

**Graph 1 (Undirected):**
- col_pointers = [0, 2, 5, 8, 11, 12]
- row_indices = [1, 2, 0, 2, 3, 0, 1, 3, 1, 2, 4, 3]

**Graph 2 (Directed):**
- col_pointers = [0, 0, 2, 4, 5, 7]
- row_indices = [0, 3, 0, 1, 2, 1, 3]
"""

# Graph 1: Undirected
col_pointers_1 = [0, 2, 5, 8, 11, 12]
row_indices_1 = [1, 2, 0, 2, 3, 0, 1, 3, 1, 2, 4, 3]
values_1 = [1]*12
vertices = ['A','B','C','D','E']
V = len(vertices)

# Build adjacency matrix
adj_matrix_1 = [[0]*V for _ in range(V)]
for col in range(V):
    start = col_pointers_1[col]
    end = col_pointers_1[col+1]
    for i in range(start, end):
        row = row_indices_1[i]
        adj_matrix_1[row][col] = values_1[i]
        adj_matrix_1[col][row] = values_1[i]  # undirected

# Print adjacency matrix
print("Adjacency Matrix (Graph 1):")
print("   " + " ".join(vertices))
for i, row in enumerate(adj_matrix_1):
    print(vertices[i], row)

# ASCII Graph Diagram
graph1_diagram = """
      A
     / \\
    B---C
     \\  |
      D
      |
      E
"""
print("\nGraph 1 Diagram (ASCII):")
print(graph1_diagram)

# Graph 2: Directed
col_pointers_2 = [0,0,2,4,5,7]
row_indices_2 = [0,3,0,1,2,1,3]
values_2 = [1]*7

# Build adjacency matrix
adj_matrix_2 = [[0]*V for _ in range(V)]
for col in range(V):
    start = col_pointers_2[col]
    end = col_pointers_2[col+1]
    for i in range(start,end):
        row = row_indices_2[i]
        adj_matrix_2[row][col] = values_2[i]

# Print adjacency matrix
print("Adjacency Matrix (Graph 2):")
print("   " + " ".join(vertices))
for i, row in enumerate(adj_matrix_2):
    print(vertices[i], row)

# ASCII Graph Diagram
graph2_diagram = """
A → B → C → D
|         ↑
└─────── D → E
B → E
"""
print("\nGraph 2 Diagram (ASCII):")
print(graph2_diagram)

# Unique cycle in directed graph
print("Unique Cycle in Graph 2: B → C → D → B")

print("=== DP Recursion Tree (Activity Selection) ===\n")

dp_tree = """
c[0,4]
├─ choose a1
│  ├─ c[0,1] = 0
│  └─ c[1,4]
│     ├─ choose a2
│     │  ├─ c[1,2] = 0
│     │  └─ c[2,4]
│     │     ├─ choose a3
│     │     └─ ...
│     └─ choose a3
└─ choose a2
   ├─ c[0,2]
   └─ c[2,4]
"""
print(dp_tree)

print("\n=== Greedy Activity Selection Timeline ===\n")
greedy_timeline = """
Time →
| a1 |----|
       | a2 |----| (overlaps, skipped)
             | a3 |----| (selected)
| a4 |----| (skipped)
"""
print(greedy_timeline)