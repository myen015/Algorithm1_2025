# -*- coding: utf-8 -*-
"""Welcome To Colab

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/notebooks/intro.ipynb
"""

from collections import deque

# 1. Tree node class
class TreeNode:
    def __init__(self, weight):
        self.weight = weight
        self.children = []

# 2. Generate tree of given depth
def generate_tree(weight, n, depth):
    node = TreeNode(weight)
    if depth > 0:
        child_weight = weight / n
        for _ in range(n):
            node.children.append(generate_tree(child_weight, n, depth - 1))
    return node

# 3. DFS (recursive) sum of weights
def dfs_sum(node):
    total = node.weight
    for child in node.children:
        total += dfs_sum(child)
    return total

# 4. BFS (iterative) sum of weights
def bfs_sum(root):
    total = 0
    queue = deque([root])
    while queue:
        node = queue.popleft()
        total += node.weight
        for child in node.children:
            queue.append(child)
    return total

# 5. DFS/BFS with alternating sign
def dfs_flip(node, sign=1):
    total = node.weight * sign
    for child in node.children:
        total += dfs_flip(child, -sign)
    return total

def bfs_flip(root):
    total = 0
    queue = deque([(root, 1)])  # (node, sign)
    while queue:
        node, sign = queue.popleft()
        total += node.weight * sign
        for child in node.children:
            queue.append((child, -sign))
    return total

# 6. Recursive and iterative BFS
def bfs_recursive(level_nodes):
    if not level_nodes:
        return 0
    next_level = []
    total = 0
    for node in level_nodes:
        total += node.weight
        next_level.extend(node.children)
    return total + bfs_recursive(next_level)

def bfs_iterative(root):
    return bfs_sum(root)

# 7. Why DFS can be recursive, BFS not recommended
# DFS uses the call stack; depth is limited, so recursion is fine.
# BFS requires storing all nodes at a level for recursion, which grows quickly
# and risks stack overflow. Iterative BFS with a queue is safer.

# 8. Test all cases
if __name__ == "__main__":
    n_values = [2, 3, 4]
    depth = 3

    for n in n_values:
        print(f"\n Testing n={n}, depth={depth} ")
        root = generate_tree(1, n, depth)

        print("DFS sum:", dfs_sum(root))          # should be 1
        print("BFS sum:", bfs_sum(root))          # should be 1
        print("DFS flip sum:", dfs_flip(root))    # should be ±1
        print("BFS flip sum:", bfs_flip(root))    # should be ±1
        print("BFS recursive sum:", bfs_recursive([root]))  # should be 1
        print("BFS iterative sum:", bfs_iterative(root))    # should be 1